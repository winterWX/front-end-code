#  MDN 
一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包

# 个人理解
一个普通的函数，能访问外层作用域的自由变量，这个函数就是闭包
广义上： js中的函数都是闭包
狭义上： js中一个函数访问了外层作用域的自由变量，那么这个函数就是闭包


{
    函数背景：{
        1.函数做为一等公民，函数可以被当作参数使用，可以做为返回值使用，加之函数本声就是一个对象。
        2.函数具备局部作用域
        3.函数在浏览器解析时就已经在内存里确定了函数内部可访问的作用域范围，自己本身加父级作用域
    }
    闭包的概念：函数内部可以访问函数外部自由变量，这个样的组合就叫闭包。 “函数内部可以访问函数外部自由变量” 这是js语言所具备的能里，所以闭包只是一个表达这样种形式的一个名词而已。
    开发中存在的问题: {
        1.全局作用域下全局变量可以保存状态的变更，在任何地方都能访问到。但是随着全局变量的增多会带来，变量重新定义被覆盖，变量值被篡改等问题，也就是全局污染的问题
        2.全局作用域下某些计算结果会被重复计算。就会导致js性能的问题
    }
    问题解决：{
        1.将全局变量的全局属性可以添加到函数里，变成局部作用域下的私有属性，全局作用域下如果想用局部属性，可以将属性返回值的形式暴露出去。外界只是只读属性。
        2.将计算过程以及计算结果封装到函数局部作用域里， 最后将结果暴露给全局属性进行接收。全局属性做为接收者，一直指向封装函数的内部地址，所以此函数调用完不会被销毁，一直保存在内存里
        3.函数可以访问外部变量做为函数内部逻辑的依赖。
    }
    由此就会形成闭包所具有的特点：{
        1. 嵌套使用
        2. 函数内部可以引用外变量
        3. 结果可以被返回
    }
    闭包无处不在：{
        如: forEach,map filter 等方法的回调
        es6 module 之前的 模块化 (function(){})()
        promise 的回调
        ajax
        react里的 hooks
        vue里data(){return()}
        防抖节流
        等等
    }
    不恰到闭包使用会造成内存泄漏：{
        1.如定时器没有被及时清除
        2.获取某个节点对象，保存在全局变量里，等节点删除了. 变量没有没清空，导致节点对象一直存在内存里
        3.意外创建的全局变量，使用不当会被一直存在全局对象中不会被释放
    }
    浏览器有自身的垃圾回收机制 GC：{
        采用： 标记清除 和 引用计数
    }
}