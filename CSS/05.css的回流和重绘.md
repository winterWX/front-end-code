# 浏览器的回流和重绘
# https://segmentfault.com/a/1190000017329980

# 浏览器的渲染过程：

/** 
*   1. html 通过 html parse, 生成Dom树。
*   2. Css 通过 Css parse, 生成 css Dom树。
*   3. 将Dom树和css Dom树，进行合并，就会生成渲染树:{
        <1></1>. dom树的根节点开始遍历,找到 css Dom树中对应的规则,并应用他们。
        <2></2>. 根据每个可见节点以及对应的样式,组合生成渲染树。
        不可见节点: {
            1. 一些不会输出的节点,比如 script meta link等。
            2. 一些通过css进行隐藏的节点,比如 display: none。 (注意: 利用visibility 和 opacity隐藏的节  点,还是会显示在渲染树上, 通过display: none 的节点不会显示在渲染树上) 
        }
    }
*   4. 根据渲染树以及回流得到的几何信息，转成节点的绝对像素。
*   5. 将像素发给GPU(Graphics Processing Unit,图像处理器)，展示在页面上。
*/

# 回流
    就是根据渲染树，从渲染树的根节点开始遍历，计算每个树节点在设备视口的确切位置 和 大小，这个计算过程就是回流。

# 重绘
    根据渲染树和回流阶段，就会知道每个可见节点的样式和具体位置和大小，然后将节点的几何信息转成屏幕上的实际像素，这个阶段就是重绘。

## 注意：回流一定会引起重绘, 重绘不会引起回流

# 引起回流和重绘的发生

1. 页面首次加载的时候。
2. 增加或者删除可见Dom元素的时候。
3. 元素的尺寸发生变化的时候。
4. 内容发生变化时。
5. 浏览器的窗口尺寸发生变化了。


#  避免引起回流和重绘的方案

1. 浏览器会通过队列的形式批量执行重排,进行优化.(队列的执行是到一定的事件段就会自动清空队列,但是当获取布局信息的操作时,就会强制清空队列)
   布局信息有 offsetTop offsetLeft offsetHeight getComputedStyle
2. 由于回流和重绘的操作比较昂贵, 合并多次对Dom和样式的修改,然后一次性处理
3. 批量修改Dom的时候 :{
    1.将元素脱离文档流
    2.对其进行多次修改 
    3.将元素带回到文档中 
}
4.  避免触发同步布局事件
5.  对于复杂动画效果,使用绝对定位让其脱离文档流