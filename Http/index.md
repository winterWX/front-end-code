对http的简述

# https://juejin.cn/post/7003323677294985247

# https://segmentfault.com/a/1190000011172823

# https://segmentfault.com/a/1190000016975064 (重点)

# https://segmentfault.com/a/1190000018717463 (浏览器缓存)

# https://segmentfault.com/a/1190000040463262 (get和post 的区别)

# https://juejin.cn/post/6844904202863394830 (状态码)


# http的发展历程

http1.0:
    1.每次请求都要建立tcp连接(tcp属于传输层，提供了面向连接，字节的可靠传输，3握，4挥手，SYN请求序列号，ACK响应序列号)
    2.请求完就会断开，再次请求就需要重新建立连接
    3.不会跟踪每个客户，也不会记录请求的信息

    缺陷： 如果请求资源多的话，就会不停的建立和断开，造成交互延迟性能问题以及占用请求时间

http1.1:
    1.允许同一个TCP连接，可以传送多个请求和响应，同一个域名下tc传送请求数最大是6个，管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟
    2.增加更多的请求头和响应头的改进对http1.0进行扩充
    如： 
        - Host主机名字段，可以用来指定访问服务器上的哪个WEB站点
        - Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接，在一定时间内保持连接(连接是有时间控制)
        - Cookie状态管理
        - Referer，从哪个资源访问服务器，进行安全校验
        - User-Agent，请求环境，比如浏览器内核
        - 缓存，强制缓存优先级高于对比缓存
            - 强制缓存Cache-Contorl: no-cache，no-store，public，private或max-age=0, must-revalidate控制浏览器的缓存，相比http1.0的Expires字段（设置复杂，采用绝对时间，客户端可能与服务端不一致，导致缓存失效） 不请求服务器，disk cache,状态码200
            - 对比缓存Last-Modified & If-Modified-Since：如果强制缓存失效，通过对比缓存去判断是否刷新资源，如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。请求服务器，一致，返回304，不一致则更新资源，返回200
            - 对比缓存Etag & If-None-Match，优先级高于Last-Modified：Etag字段和它所表示的文件hash，也就是进行内容比对
        - 跨域，相对jsonp只能使用get请求，这种支持所有类型的请求
            - 简单请求，请求响应头会添加origin,用来说明本次请求来自哪个源（协议 + 域名 + 端口）
            - 设置Access-Control-Allow-Origin响应头，*表示接受所有跨域请求，也可以指定源，增强安全性
    3.增加了请求方法
    http1.0共有GET, POST 和HEAD三种请求方法；
    http1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT方法
    

    存在的缺陷： 
        1.会造成队头堵塞(当队头的请求不能收到响应的资源，它将会堵塞后面的请求)的问题，服务器处理必须是上一个请求处理完成才会处理下一个。
        2.串行文件传输，只要上一个完成之后，才能进行下一个
        3.服务器会设置最大并发数Apache,当超过了，就需要排队等待

    http2
        0. HTTP/2 二进制协议而不是文本协议，二进制协议流的概念
        1.头部压缩，server push, 多路复用。 
        2.多路复用，并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束，http1.1是传送request和response都是基于文本的，所有的数据都必须按照顺序传送，不能并行传送
        因为接收端不知道字符的顺序。http2引入了二进制和流的概念，传输的时候帧就会对数据进行顺序标识，浏览器收到数据后就会
        对数据根据序列号进行合并，不会出现乱码。当有了序列，服务器就可以并行数据传输。
        3.同一个域名下请求都是基于流的形式。

        MDN:
        1.HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
        2.这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。
        3.压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
        4.其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。


        以前我们做的性能优化不适用于HTTP/2了

        JS文件的合并。我们现在优化的一个主要方向就是尽量的减少HTTP的请求数， 对我们工程中的代码，研发时分模块开发，上线时我们会把所有的代码进行压缩合并，合并成一个文件，这样不管多少模块，都请求一个文件，减少了HTTP的请求数。但是这样做有一个非常严重的问题：文件的缓存。当我们有100个模块时，有一个模块改了东西，按照之前的方式，整个文件浏览器都需要重新下载，不能被缓存。现在我们有了HTTP/2了，模块就可以单独的压缩上线，而不影响其他没有修改的模块。

        # 多域名提高浏览器的下载速度。

        之前我们有一个优化就是把css文件和js文件放到2个域名下面，这样浏览器就可以对这两个类型的文件进行同时下载，避免了浏览器6个通道的限制，这样做的缺点也是明显的，1.DNS的解析时间会变长。2.增加了服务器的压力。有了HTTP/2之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。







