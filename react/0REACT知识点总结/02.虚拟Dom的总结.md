## 官网对虚拟 diff 的解释 https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children

# render 会生成一个 js 对象。

(1).新旧 dom 进行对比。

# 什么是虚拟 Dom

  # (1).react 中虚拟 Dom 是 render 后生成的一个 JS 对象。
  # (2).是真实 Dom 的映射。
  # (3).批量更新 Dom 节点。
  # 为什么使用虚拟 Dom
  # (1).提高了浏览器的性能优化，也提高了用户的体验效果。
  # (2).虚拟 Dom 比原生 Dom 更新块。
  # (3).diff 算法能比较出新旧虚拟 Dom 的差异。
  # react diff 三大策略

  <!--  # (1).策略一 虚拟DOM树分层比较 
            1.同层节点进行比较，忽略Dom节点跨层级的移动操作。
            2.同一父节点下的所有子节点，当发现子节点不存在了，
              则该节点及其子节点会被完全删除掉，不会用于进一步的比较。
            3.当一个节点及其子节点移动到另一个节点下，就会直接销毁这个节点，
              并会重新创建子树，然后挂到目标节点上。
        
        # (2).策略二 组件间的比较 
            1.如果是同一个组件类型，就按照三大原则进行比较。
            2.如果不是同一类型的组件，就会替换整个组件下的所有子节点。
          
        # (3).策略三 元素间的比较 
            1.当节点处于同一层的时候，react提供了三种节点操作的方法 插入，删除，移动
            2.根据key的值进行操作。
 -->

# 1.diff 算法首先是从两颗树的根节点开始的.
    (1).当根节点为不同类型的元素时,直接销毁旧的树，建立起新的树。
    (2).当根节点为同类型的元素时,React会保留DOM节点，仅比对有改变的属性更新。
    (3).对比同类型组件元素时，组件更新时实例会保持不变，渲染时保持state一致，react会更新组件实例的props
           保证和最新的元素一致性。
    (4).对dom元素的子节点进行递归的比较，同时遍历两个子元素的列表，当产生差异时生成一个 mutation。

# key 的出现
    diff 对比子元素时，如果给子元素的末尾加新的元素，更新的开销就比较小。
    diff 对比子元素时，如果给子元素的首端加新的元素，react 并不会智能判断出哪些元素可以复用
    而是会重建每一个子元素，这样更新的开销就比较大。
    为了解决 开销的问题。react 要求遍历子元素时绑定唯一的key。

# key 的作用
    # react 要求绑定唯一的key,是为了在diff比较的时候提高性能的优化，就是减少元素的创建。
    绑定key属性
      在diff对比前，key可以帮助react辨别元素的增加或者删除，然后对元素进行 插入，删除，移动 的操作。
    不绑定key属性
        如果不绑定key,react将默认使用索引作为元素的key。
        当基于下标的元素重新排序时，组件的state就会遇到问题,组件是基于元素的key是否要更新或者复用，
        当顺序变了，key也就变了，就会导致非受控组件的state可能互相篡改（误认为是同一个元素,只是更新内容）。

        顺序不变的时候，影响不大。

# 虚拟 Dom
    1.使用 react.createElement()函数调用生成的对象。用来描述用户界面和 Dom 解构的 
    2.是对真实 Dom 的映射 
    3.能更好的跨平台 
    4.虚拟 Dom 会被缓存到内存里 
    5.当状态发生改变会进行新旧 dom 树的对比，批量更新 Dom,提高页面性能

    缺点； 
      1.页面首次渲染，先生成虚拟 dom 对象，然后将 dom 对象插入到页面上，可能会造成页面白屏的现象 
      2.虚拟 Dom 会被缓存到内存里,不恰当的使用会造成内存泄漏
