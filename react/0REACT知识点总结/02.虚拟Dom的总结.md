## 官网对虚拟diff的解释 https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children

# render 会生成一个js对象。

  (1).新旧dom进行对比。

# 什么是虚拟Dom
   # (1).react中虚拟Dom是render后生成的一个JS对象。
   # (2).是真实Dom的映射。
   # (3).批量更新Dom节点。

# 为什么使用虚拟Dom 
   # (1).提高了浏览器的性能优化，也提高了用户的体验效果。
   # (2).虚拟Dom比原生Dom更新块。
   # (3).diff算法能比较出新旧虚拟Dom的差异。

# react diff 三大策略
  
  <!-- # (1).策略一 虚拟DOM树分层比较 
        1.同层节点进行比较，忽略Dom节点跨层级的移动操作。
        2.同一父节点下的所有子节点，当发现子节点不存在了，
          则该节点及其子节点会被完全删除掉，不会用于进一步的比较。
        3.当一个节点及其子节点移动到另一个节点下，就会直接销毁这个节点，
          并会重新创建子树，然后挂到目标节点上。
        
  # (2).策略二 组件间的比较 
        1.如果是同一个组件类型，就按照三大原则进行比较。
        2.如果不是同一类型的组件，就会替换整个组件下的所有子节点。
    
  # (3).策略三 元素间的比较 
     
        1.当节点处于同一层的时候，react提供了三种节点操作的方法 插入，删除，移动
        2.根据key的值进行操作。 -->


  #  1.diff算法首先是从两颗树的根节点开始的.
  
        (1).当根节点为不同类型的元素时,直接销毁旧的树，建立起新的树。
        (2).当根节点为同类型的元素时,React会保留DOM节点，仅比对及更新有改变的属性。
        (3).对比同类型组件元素时，组件更新时实例会保持不变，渲染时保持state一致，react会更新组件实例的props
           保证和最新的元素保持一致。
        (4).对dom元素的子节点进行递归的比较，同时遍历两个子元素的列表，当产生差异时生成一个 mutation。
      
    
  # key 的出现

    diff 对比子元素时，如果给子元素的末尾加新的元素，更新的开销就比较小。
    diff 对比子元素时，如果给子元素的首端加新的元素，react 并不会智能判断出哪些元素可以复用
    而是会重建每一个子元素，这样更新的开销就比较大。
    为了解决 开销的问题。react 要求遍历子元素时绑定唯一的key。


  # key 的作用
    # react 要求绑定唯一的key,是为了在diff比较的时候提高性能的优化，就是减少元素的创建。

    绑定key属性
      在diff对比前，key可以帮助react辨别元素的增加或者删除，然后对元素进行 插入，删除，移动 的操作。
    
    不绑定key属性
        如果不绑定key,react将默认使用索引作为元素的key。
        当基于下标的元素重新排序时，组件的state就会遇到问题,组件是基于元素的key是否要更新或者复用，
        当顺序变了，key也就变了，就会导致非受控组件的state可能互相篡改（误认为是同一个元素,只是更新内容）。
        
        顺序不变的时候，影响不大。