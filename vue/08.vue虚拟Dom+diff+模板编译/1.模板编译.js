# complier - core对template模板进行解析

编译时: {
    parse阶段: {
        1. 解析模板生成原始的AST对象, 对象里包含着模板的多个属性。
    }
    transform阶段: {
        对parse阶段生成的AST树, 进行转换操作, 根据不同的AST节点添加不同的选项参数
        2. 如果cacheHandlers的值为true, 则会开起事件缓存机制
        3. 如果hoistStatic的标识值为true, 该节点就会启用静态节点机制标记为静态节点, 生成节点对应的变量名, 会把静态节点放到render函数外部，
        代码生成阶段直接在渲染函数里复用，不会进行重新创建。
        4. 对不同的节点打上patchflag标记, diff比较的时候根据不同的patchflag, 使用不同的patch方法,
            然后生成新的AST语法树对象，里面包含这存储函数的Helpers和Hoists存储静态节点以及其他节点属性。
    }
    codegen阶段：{
        将生成的AST树通过函数调用, 生成虚拟Dom对象， 然后渲染函数进行渲染生成真实的Dom
    }
}

运行时: {
    新旧Dom树进行比较时，只会比较同级有动态标记的节点，没有动态标记的直接复用。
}

区别是:

vue2: {
    diff是进行全量比较的, 每个节点不论写死的还是动态的都会一层一层比较, 浪费新能.
}

vue3: {
    1. 非全量比较Diff, 只对比带有patchFlag的节点, 在编译的时候增加了静态标记, 只是对比有静态标记的元素
    2. 静态提升, vue2无论元素是否参与更新, 每次都会重新创建然后再渲染, vue3对于不参与更新的元素, 会做静态提升, 只会被创建一次, 在渲染时直接复用即可
    3. vue3设置了事件侦听器缓存机制, 当事件再次被触发时, 只需要从缓存中调用即可, 无需再重新创建, vue2绑定事件每次触发都会重新生成全新的函数去更新。
    4. vue3更好的TS支持
    5. 增加了组合API / 注入API
    6. vue3支持多根节组件
    7. vue3通过将大多数全局API和内部程序ES模块导出的形式，是得打包工具可以分析出有依赖的模块，删除没有依赖的模块，使得打包的体积变小了
}