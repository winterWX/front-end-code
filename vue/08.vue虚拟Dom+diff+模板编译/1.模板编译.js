# complier-core对template模板进行解析

编译时: { 
    1.parse阶段: {
        1.每解析完一个标签、文本、注释等节点时,Vue 就会生成对应的 AST 节点,并且会把已经解析完的字符串给截断, 形成tokens数组
        对象的AST树。
    }

    2.transform阶段: {
        1. 对parse阶段生成的AST树,进行转换操作,根据不同的AST节点添加不同的选项参数
        2. 如果cacheHandlers的值为true,则会开起事件缓存机制
        3. 会对不参与更新的元素进行静态提升
        4. 对不同的节点打上patchflag标记，diff比较的时候根据不同的patchflag, 使用不同的patch方法,
        生成新的AST语法树。   
    }
   
    3.codegen阶段：{
        将生成的AST树，通过函数调用生成，虚拟Dom对象， 然后渲染函数进行渲染生成真实的Dom
    }

}

运行时: {
    新旧Dom树进行比较时，只会比较同级有动态标记的节点，没有动态标记的直接复用。
}


区别是: 

vue2: { 
   diff是进行全量比较的, 每个节点不论写死的还是动态的都会一层一层比较,浪费新能.
}

vue3: {
    1. 非全量比较Diff, 只对比带有patchFlag的节点,在编译的时候增加了静态标记,只是对比有静态标记的元素
    2. 静态提升, vue2无论元素是否参与更新,每次都会重新创建然后再渲染,vue3对于不参与更新的元素, 会做静态提升,只会被创建一次,在渲染时直接复用即可
    3. vue3设置了事件侦听器缓存机制, 当事件再次被触发时,只需要从缓存中调用即可,无需再重新创建, vue2绑定事件每次触发都会重新生成全新的函数去更新。
    4. vue3更好的TS支持
    5. 增加了组合API/注入API
    6. vue3支持多根节组件
    7. vue3通过将大多数全局API和内部程序ES模块导出的形式，是得打包工具可以分析出有依赖的模块，删除没有依赖的模块，使得打包的体积变小了
}